Welcome to Bismuth, a digital distributed self-regulating database system whose primary application is currency, 
and its first application is mining. Bismuth is not based on code of BTC or any of it's derivates, it is only inspired
by some ideas laid down by Andreas M. Antonopoulos, Satoshi Nakamoto (BitCoin), Sunny King (Peercoin), John Connor (vCash), NXT and
ETH developers.

Bismuth does not draw any code from other repositories, instead it reformulates the cryptocurrency code in its own terms to be easily 
readable, compatible across all platforms, integrated into business solutions with utmost ease and most importantly open for
development to wide public through it's simplicity, while minimizing the security risk for custom code implementations.

Bismuth vastly differs from the mentioned systems in many ways and some concepts are very different, in pursuit of improved
performance and removal of deliberate, non-technical limitations like the block size. The main difference is that Bismuth does not
differ between a block and a transactions and regards them as synonymous. This means that coins can be spend instantly, because the 
transaction time is equal to zero + technical limitations of the network.

The risk of network overload resulting from this feature is eliminated by flexible fees. With the growing network usage, the fees
also rise. However when the network is not used extensively, fees are almost non-existent. The fees are currently burned, to stimulate
energy expenditure in real-life systems and eliminate issues associated with POS mechanisms (hoarding). The risk of double spending is
mitigated through the longest chain rule, and every transaction is checked against balance. Unlike the sophisticated input/output 
system, Bismuth uses a simple balance addition, substraction and comparison.

One of the improvements is derived from Bitcoin's issues with the memory pool overload, which is capable of crashing the client.
Bismuth uses a database (backup.db) for this purpose, instead of storing incoming transactions in RAM. This enables Bismuth to run
on low-end devices, since price of storage is significantly lower than that of RAM and does not need to impact system performance
directly. When a fork occurs on the network and a different node is selected based on the longest chain rule, the same database is
used to backup local transactions in order to reinsert them later.

There is a central transaction processing core in every node, which handles transaction verification and synchronization and makes
this system reliable. However, there are multiple independent connectors in the peer to peer system, based on whether connections are
incoming or outgoing and whether the node is active or passive. Active nodes are able to receive and send requests, while passive 
nodes are only capable of sending.

workflow
network functions accessible to anyone
readable database system
dapps/openfield
mining system
actual numeric specifications
sidechains
megablocks
compressions



